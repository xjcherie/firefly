## 静态代理
需要代理对象和目标对象实现一样的接口
优点：
1. 可以在不修改目标对象的前提下扩展目标对象的功能。
缺点：
1. 冗余。会产生过多的代理类。   
2. 不易维护。随着接口增加方法，目标对象与代理对象都要进行相应修改。

## JDK原生动态代理
动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。
参数动态创建代理对象。三个参数的意义如下：
1. loader，指定代理对象的类加载器；
2. interfaces，代理对象需要实现的接口，可以同时指定多个接口；
3. handler，方法调用的实际处理者，代理对象的方法调用都会转发到这里。
注：newProxyInstance()会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。
特点：
1. 代理对象是在程序运行时产生的，而不是编译期；
2. 对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法，在invoke()方法里可以加入任何逻辑。

## CGLIB proxy
CGLIB (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。
特点
1. JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。
如果想代理没有实现接口的类，就可以使用CGLIB实现。
2. 它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。
3. CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。

## 小结
1. 静态代理只为一个目标对象服务，如果目标对象过多，则会产生很多代理类。
2. JDK动态代理需要目标对象实现业务接口
3. 静态代理在编译时产生class字节码文件，可以直接使用，效率高。
4. JDK动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。
5. CGLIB代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题
6. CGLIB会继承目标对象，需要重写方法，所以目标对象不能为final类。
